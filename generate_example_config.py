#!/usr/bin/env python3

import argparse
import subprocess
from pathlib import Path
import sys
import re
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def parse_variables(content):
    """Parse ansible-doc output and extract variable information."""
    # Split into role sections
    role_sections = re.split(r'>\s+(.+)\s*', content)[1:]
    result = []
    role_blocks = []

    # Process each role section 
    for i in range(0, len(role_sections), 2):
        role_name = role_sections[i].strip()
        section = role_sections[i + 1]
        logger.info(f"Processing role: {role_name}")
        variables = []

        # Find top-level variable definitions with their descriptions and defaults
        var_blocks = re.finditer(r'^(=|\-)\s+(\w+)\n\s+([^\n]+?)(?:\n\s+default: ([^\n]+))?$', 
                               section, re.MULTILINE)
        
        vars_processed = 0
        for match in var_blocks:
            is_required = match.group(1) == '='
            var_name = match.group(2)
            description = match.group(3).strip()
            default = match.group(4)  # Will be None if no default found
            
            # Skip internal variables and nested options
            if var_name.startswith('_'):
                logger.debug(f"Skipping internal variable: {var_name}")
                continue
                
            logger.debug(f"Found variable: {var_name} (required: {is_required})")
            
            # Format output lines
            variables.append(f"# {'REQUIRED' if is_required else 'Optional'}: {description}")
            if default:
                variables.append(f"# Default: {default}")
                
            variables.append(f"#{var_name}")
            variables.append("")  # Empty line for readability
            vars_processed += 1

        # Add the formatted variables to the role_blocks, if any were found
        if len(variables) != 0:
            logger.info(f"Found {vars_processed} variables for role {role_name}")
            block = f"\n#### {role_name}\n################################################################\n" + '\n'.join(variables)
            role_blocks.append((role_name.lower(), block))
        else:
            logger.debug(f"No public variables found for role {role_name}")

    # Sort role_blocks alphabetically by role_name
    for _, block in sorted(role_blocks):
        result.append(block)
        
    return result

def generate_variables_file(roles_dir, roles, variables_path):
    try:
        subprocess.run(
            ["ansible-doc", "-t", "role", "-r", str(roles_dir)] + roles,
            check=True,
            stdout=variables_path.open("w"),
        )
        print(f"Generated {variables_path}")
    except subprocess.CalledProcessError as e:
        print(f"Error running ansible-doc: {e}", file=sys.stderr)
        sys.exit(1)

def generate_example_config(project_root):
    vars_file = project_root / "VARIABLES"
    if not vars_file.exists():
        logger.error(
            "VARIABLES file not found. "
            "Make sure you're running this script from the project root directory. "
            f"Current directory: {project_root}"
        )
        return 1
    
    try:
        with open(vars_file, 'r') as f:
            content = f.read()
        
        variables = parse_variables(content)
        
        # Write output to group_vars
        output_dir = project_root / "group_vars" / "all"
        output_dir.mkdir(parents=True, exist_ok=True)
        output_file = output_dir / "main.yml.example"
        
        with open(output_file, 'w') as f:
            f.write("---\n")  # YAML header
            f.write("# Autogenerated. Full variables descriptions can be found in VARIABLES file. \n")  
            f.write('\n'.join(variables))
            f.write('\n')
        
        logger.info(f"Variables written to {output_file}")
        return 0
        
    except Exception as e:
        logger.error(f"Error processing variables: {e}")
        return 1

def cleanup_variables_file(variables_path):
    """Remove everything after the role name in the VARIABLES file header lines."""
    pattern = re.compile(r'^(>\s+\w+).*$', re.MULTILINE)
    with variables_path.open("r") as f:
        content = f.read()
    # Replace lines like '> NGINX    (/path/to/role)' with '> NGINX'
    cleaned = re.sub(r'^(>\s+\S+).*$', r'\1', content, flags=re.MULTILINE)
    with variables_path.open("w") as f:
        f.write(cleaned)
    logger.info(f"Cleaned up role paths in {variables_path}")

def main():
    parser = argparse.ArgumentParser(
        description="Generate documentation for Ansible roles."
    )
    parser.add_argument(
        "playbook_root",
        nargs="?",
        default=".",
        help="Path to the playbook root (default: current directory)"
    )
    args = parser.parse_args()

    playbook_root = Path(args.playbook_root).resolve()
    script_dir = Path(__file__).parent.resolve()
    print(f"Generating documentation in {script_dir}")

    roles_dir = playbook_root / "roles"
    if not roles_dir.is_dir():
        print(f"Roles directory not found: {roles_dir}", file=sys.stderr)
        sys.exit(1)

    # Find roles
    roles = sorted([
        d.name for d in roles_dir.iterdir()
        if d.is_dir() and not d.name.startswith('.')
    ])

    if not roles:
        print("No roles found.", file=sys.stderr)
        sys.exit(1)

    # Generate VARIABLES file
    variables_path = playbook_root / "VARIABLES"
    generate_variables_file(roles_dir, roles, variables_path)

    # Clean up VARIABLES file to hide role paths
    cleanup_variables_file(variables_path)

    # Generate example config
    result = generate_example_config(playbook_root)
    sys.exit(result)

if __name__ == "__main__":
    main()
