#!/usr/bin/env python3

import re
import logging
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

def parse_variables(content):
    """Parse ansible-doc output and extract variable information."""
    # Split into role sections
    role_sections = re.split(r'>\s+(.+)\s+\(', content)[1:]
    result = []
    
    # Process each role section 
    for i in range(0, len(role_sections), 2):
        role_name = role_sections[i].strip()
        section = role_sections[i + 1]
        logger.info(f"Processing role: {role_name}")
        variables = []

        # Find top-level variable definitions with their descriptions and defaults
        var_blocks = re.finditer(r'^(=|\-)\s+(\w+)\n\s+([^\n]+?)(?:\n\s+default: ([^\n]+))?$', 
                               section, re.MULTILINE)
        
        vars_processed = 0
        for match in var_blocks:
            is_required = match.group(1) == '='
            var_name = match.group(2)
            description = match.group(3).strip()
            default = match.group(4)  # Will be None if no default found
            
            # Skip internal variables and nested options
            if var_name.startswith('_'):
                logger.debug(f"Skipping internal variable: {var_name}")
                continue
                
            logger.debug(f"Found variable: {var_name} (required: {is_required})")
            
            # Format output lines
            variables.append(f"# {'REQUIRED' if is_required else 'Optional'}: {description}")
            if default:
                variables.append(f"# Default: {default}")
                
            variables.append(f"#{var_name}")
            variables.append("")  # Empty line for readability
            vars_processed += 1

        # Add the formatted variables to the result, if any were found
        if len(variables) != 0:
            logger.info(f"Found {vars_processed} variables for role {role_name}")
            result.append(f"\n#### {role_name}")
            result.append("################################################################\n")
            result.append('\n'.join(variables))
        else:
            logger.debug(f"No public variables found for role {role_name}")
    
    return result

def main():
    project_root = Path.cwd()
    vars_file = project_root / "VARIABLES"
    
    if not vars_file.exists():
        logger.error(
            "VARIABLES file not found. "
            "Make sure you're running this script from the project root directory. "
            f"Current directory: {project_root}"
        )
        return 1
    
    try:
        with open(vars_file, 'r') as f:
            content = f.read()
        
        variables = parse_variables(content)
        
        # Write output to group_vars
        output_dir = project_root / "group_vars" / "all"
        output_dir.mkdir(parents=True, exist_ok=True)
        output_file = output_dir / "main.yml.example"
        
        with open(output_file, 'w') as f:
            f.write("---\n")  # YAML header
            f.write("# Autogenerated. Full variables descriptions can be found in VARIABLES file. \n")  
            f.write('\n'.join(variables))
            f.write('\n')
        
        logger.info(f"Variables written to {output_file}")
        return 0
        
    except Exception as e:
        logger.error(f"Error processing variables: {e}")
        return 1

if __name__ == "__main__":
    exit(main())
